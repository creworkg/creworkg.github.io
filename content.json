{"meta":{"title":"ZEN","subtitle":"","description":"Software Engineer","author":"Seeker","url":"https://creworkg.github.io","root":"/"},"pages":[{"title":"About me","date":"2022-09-14T02:10:22.000Z","updated":"2022-09-17T02:16:52.366Z","comments":true,"path":"about/index.html","permalink":"https://creworkg.github.io/about/index.html","excerpt":"","text":"你站在何处，你就深深地挖掘！ 下面就是清泉！ 让愚昧的家伙去怨嗟： ”最下面是——地狱！” ——尼采 Brief introduction 虚心若愚，求知若渴 一个喜欢技术的工程师。"},{"title":"tags","date":"2022-09-13T06:41:48.000Z","updated":"2022-09-13T06:48:06.052Z","comments":true,"path":"tags/index.html","permalink":"https://creworkg.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-09-13T06:47:55.000Z","updated":"2022-09-13T06:49:53.521Z","comments":true,"path":"categories/index.html","permalink":"https://creworkg.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"什么是企业的核心竞争力","slug":"什么是企业的核心竞争力","date":"2022-09-14T07:52:34.000Z","updated":"2022-09-14T11:58:41.841Z","comments":true,"path":"2022/09/14/什么是企业的核心竞争力/","link":"","permalink":"https://creworkg.github.io/2022/09/14/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%81%E4%B8%9A%E7%9A%84%E6%A0%B8%E5%BF%83%E7%AB%9E%E4%BA%89%E5%8A%9B/","excerpt":"","text":"你有一只鹅，它每天下一只蛋。你把鹅蛋卖了，每天能赚不少钱。那么，你的鹅每天下的那只蛋，是你的核心竞争力吗？ 当然不是。鹅蛋从来不是核心竞争力，那只鹅才是。 你的一个个产品，就是一只只鹅蛋。他们只是结果。它们不是核心竞争力，你为什么能做出这些产品，才是你的核心竞争力。 比如，你有一个打磨了无数次的做产品的独特流程？你创造了一种员工极度负责、眼睛里容不下一个bug的文化？你有一支投入了5年，一直研究底层技术的团队？你的设计师团队，每年去20个国家采风？ 这些才是你的核心竞争力，是这些东西，让你源源不断下蛋，产生新产品。 找到这些东西，然后把它们提炼出来，当做珍宝一样保护起来，不断的训练它们，直到别人无法超越，然后复制到每件产品上去。 刘润 很多科技型公司并不重视技术，他们只重视技术带来的产品，产品带来的利润。 企业作终是要盈利的，不盈利就存不下去，这个逻辑看似没错，但是存在严重的问题。 假如你去购买一个彩电，你大概不希望彩电里的电路板上全是灰尘，导线全部搅在一起，乱七八糟，有时候电视剧播放得好好的，屏幕突然不亮了，你不得不用大力金刚掌拍一下电视机，把画面拍出来…… 公司研发一款产品，不能只看产品的样貌，更重要的是产品背后的技术。如果研发产品时走的是“野路子”，后期维护起来可能相当麻烦。产品最多也只能算是”金玉其外，败絮其中“。 看得见的是产品的外观、触感、重量，看不见的是其背后的电路、代码的设计与实现，而这些消费者看不见的东西，才真正地反映了公司的核心竞争力。 最后引用乔布斯的一句话： “如果你是个木匠，正在打造一个漂亮的五斗柜，你是不会在柜子后面用三合板的，哪怕那一面对着墙，永远没人看到它；你知道它在那里，所以即使是柜子后面，你也会用上好的木材；为了能在晚上睡个好觉，你会在审美和质量上自始至终争取做到最好。” 如有错误，欢迎指出！如需转载，请注明出处~email:&#99;&#114;&#x65;&#x61;&#116;&#x69;&#x76;&#101;&#x2e;&#119;&#111;&#114;&#x6b;&#x2e;&#103;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;欢迎交流学习！","categories":[{"name":"zen","slug":"zen","permalink":"https://creworkg.github.io/categories/zen/"},{"name":"thoughts","slug":"zen/thoughts","permalink":"https://creworkg.github.io/categories/zen/thoughts/"}],"tags":[{"name":"zen","slug":"zen","permalink":"https://creworkg.github.io/tags/zen/"}]},{"title":"freeRTOS-调度器切换线程过程分析","slug":"freeRTOS-调度器切换线程过程分析","date":"2022-09-13T09:34:27.000Z","updated":"2022-09-17T06:28:54.535Z","comments":true,"path":"2022/09/13/freeRTOS-调度器切换线程过程分析/","link":"","permalink":"https://creworkg.github.io/2022/09/13/freeRTOS-%E8%B0%83%E5%BA%A6%E5%99%A8%E5%88%87%E6%8D%A2%E7%BA%BF%E7%A8%8B%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/","excerpt":"这篇文章分析线程切换的过程为了叙述更清晰，不再贴大段的代码，而是先描述函数主要功能，再撷取重要的代码片段来讲述","text":"这篇文章分析线程切换的过程为了叙述更清晰，不再贴大段的代码，而是先描述函数主要功能，再撷取重要的代码片段来讲述 pre { overflow-y: auto; max-height: 600px; } vTaskSwitchContexttaskSELECT_HIGHEST_PRIORITY_TASK找到优先级最高的就绪任务，并将该任务的句柄赋值给 pxCurrentTCB。 有两种方式，实现的效果一样，只是效率有差异，通过遍历每一个优先级列表找到最高优先级任务 1234567891011121314151617181920212223242526#define taskSELECT_HIGHEST_PRIORITY_TASK() \\&#123; \\UBaseType_t uxTopPriority; \\ \\ /* Find the highest priority list that contains ready tasks. */ \\ portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority ); \\ configASSERT( listCURRENT_LIST_LENGTH( &amp;( pxReadyTasksLists[ uxTopPriority ] ) ) &gt; 0 ); \\ listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &amp;( pxReadyTasksLists[ uxTopPriority ] ) ); \\&#125; /* taskSELECT_HIGHEST_PRIORITY_TASK() */#define taskSELECT_HIGHEST_PRIORITY_TASK() \\ &#123; \\ UBaseType_t uxTopPriority = uxTopReadyPriority; \\ \\ /* Find the highest priority queue that contains ready tasks. */ \\ while( listLIST_IS_EMPTY( &amp;( pxReadyTasksLists[ uxTopPriority ] ) ) ) \\ &#123; \\ configASSERT( uxTopPriority ); \\ --uxTopPriority; \\ &#125; \\ \\ /* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of \\ the same priority get an equal share of the processor time. */ \\ listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &amp;( pxReadyTasksLists[ uxTopPriority ] ) ); \\ uxTopReadyPriority = uxTopPriority; \\ &#125; /* taskSELECT_HIGHEST_PRIORITY_TASK */ xPortPendSVHandler真正的线程切换，发生在这里： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960__asm void xPortPendSVHandler( void )&#123; extern uxCriticalNesting; extern pxCurrentTCB; extern vTaskSwitchContext; PRESERVE8 mrs r0, psp // 将psp指针的值赋给R0 isb /* Get the location of the current TCB. */ ldr r3, =pxCurrentTCB //将当前任务的tcb地址赋给R3 ldr r2, [r3] //获取当前任务的栈顶指针的地址 /* Is the task using the FPU context? If so, push high vfp registers. */ tst r14, #0x10 it eq vstmdbeq r0!, &#123;s16-s31&#125; //手动保持浮点寄存器 /* Save the core registers. */ stmdb r0!, &#123;r4-r11, r14&#125; //手动保存callee-saved register /* Save the new top of stack into the first member of the TCB. */ str r0, [r2] stmdb sp!, &#123;r0, r3&#125; //保存R0-R3寄存器，因为调用函数vTaskSwitchContext会破坏现场，这里是将数值保存在msp！ mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY msr basepri, r0 //屏蔽中断 dsb isb bl vTaskSwitchContext //选出最高的优先级任务 mov r0, #0 msr basepri, r0 //开启中断 ldmia sp!, &#123;r0, r3&#125; //恢复寄存器 /* The first item in pxCurrentTCB is the task top of stack. */ ldr r1, [r3] //R3始终指向已经指向pxCurrentTCB，但此时，pxCurrentTCB已经指向了新的任务tcb ldr r0, [r1] //获取新的任务栈指针 /* Pop the core registers. */ ldmia r0!, &#123;r4-r11, r14&#125; //恢复 /* Is the task using the FPU context? If so, pop the high vfp registers too. */ tst r14, #0x10 it eq vldmiaeq r0!, &#123;s16-s31&#125; //恢复 msr psp, r0 //更新psp isb #ifdef WORKAROUND_PMU_CM001 /* XMC4000 specific errata */ #if WORKAROUND_PMU_CM001 == 1 push &#123; r14 &#125; pop &#123; pc &#125; nop #endif #endif bx r14 //跳到新的任务执行&#125; xPortPendSVHandler函数执行完后，就进入了新的任务 那么这个函数是何时触发的呢？ xPortSysTickHandler12345678910111213141516171819void xPortSysTickHandler( void )&#123; /* The SysTick runs at the lowest interrupt priority, so when this interrupt executes all interrupts must be unmasked. There is therefore no need to save and then restore the interrupt mask value as its value is already known - therefore the slightly faster vPortRaiseBASEPRI() function is used in place of portSET_INTERRUPT_MASK_FROM_ISR(). */ vPortRaiseBASEPRI(); &#123; /* Increment the RTOS tick. */ if( xTaskIncrementTick() != pdFALSE ) &#123; /* A context switch is required. Context switching is performed in the PendSV interrupt. Pend the PendSV interrupt. */ portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; &#125; &#125; vPortClearBASEPRIFromISR();&#125; portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;这条语句将PenSV挂起，等到没有更高优先级中断执行时，任务切换就开始了 发现还有几个函数： vPortRaiseBASEPRI进入临界区，关闭中断 vPortClearBASEPRIFromISR开启中断 xTaskIncrementTick123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170BaseType_t xTaskIncrementTick( void )&#123;TCB_t * pxTCB;TickType_t xItemValue;BaseType_t xSwitchRequired = pdFALSE; /* Called by the portable layer each time a tick interrupt occurs. Increments the tick then checks to see if the new tick value will cause any tasks to be unblocked. */ traceTASK_INCREMENT_TICK( xTickCount ); if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE ) &#123; /* Minor optimisation. The tick count cannot change in this block. */ const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1; /* Increment the RTOS tick, switching the delayed and overflowed delayed lists if it wraps to 0. */ xTickCount = xConstTickCount; if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 &#x27;if&#x27; does not always evaluate to false as it is looking for an overflow. */ &#123; taskSWITCH_DELAYED_LISTS(); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; /* See if this tick has made a timeout expire. Tasks are stored in the queue in the order of their wake time - meaning once one task has been found whose block time has not expired there is no need to look any further down the list. */ if( xConstTickCount &gt;= xNextTaskUnblockTime ) &#123; for( ;; ) &#123; if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE ) &#123; /* The delayed list is empty. Set xNextTaskUnblockTime to the maximum possible value so it is extremely unlikely that the if( xTickCount &gt;= xNextTaskUnblockTime ) test will pass next time through. */ xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */ break; &#125; else &#123; /* The delayed list is not empty, get the value of the item at the head of the delayed list. This is the time at which the task at the head of the delayed list must be removed from the Blocked state. */ pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too. Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */ xItemValue = listGET_LIST_ITEM_VALUE( &amp;( pxTCB-&gt;xStateListItem ) ); if( xConstTickCount &lt; xItemValue ) &#123; /* It is not time to unblock this item yet, but the item value is the time at which the task at the head of the blocked list must be removed from the Blocked state - so record the item value in xNextTaskUnblockTime. */ xNextTaskUnblockTime = xItemValue; break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */ &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; /* It is time to remove the item from the Blocked state. */ ( void ) uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) ); /* Is the task waiting on an event also? If so remove it from the event list. */ if( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != NULL ) &#123; ( void ) uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) ); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; /* Place the unblocked task into the appropriate ready list. */ prvAddTaskToReadyList( pxTCB ); /* A task being unblocked cannot cause an immediate context switch if preemption is turned off. */ #if ( configUSE_PREEMPTION == 1 ) &#123; /* Preemption is on, but a context switch should only be performed if the unblocked task has a priority that is equal to or higher than the currently executing task. */ if( pxTCB-&gt;uxPriority &gt;= pxCurrentTCB-&gt;uxPriority ) &#123; xSwitchRequired = pdTRUE; &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; #endif /* configUSE_PREEMPTION */ &#125; &#125; &#125; /* Tasks of equal priority to the currently running task will share processing time (time slice) if preemption is on, and the application writer has not explicitly turned time slicing off. */ #if ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configUSE_TIME_SLICING == 1 ) ) &#123; if( listCURRENT_LIST_LENGTH( &amp;( pxReadyTasksLists[ pxCurrentTCB-&gt;uxPriority ] ) ) &gt; ( UBaseType_t ) 1 ) &#123; xSwitchRequired = pdTRUE; &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; #endif /* ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configUSE_TIME_SLICING == 1 ) ) */ #if ( configUSE_TICK_HOOK == 1 ) &#123; /* Guard against the tick hook being called when the pended tick count is being unwound (when the scheduler is being unlocked). */ if( xPendedTicks == ( TickType_t ) 0 ) &#123; vApplicationTickHook(); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; #endif /* configUSE_TICK_HOOK */ #if ( configUSE_PREEMPTION == 1 ) &#123; if( xYieldPending != pdFALSE ) &#123; xSwitchRequired = pdTRUE; &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; #endif /* configUSE_PREEMPTION */ &#125; else &#123; ++xPendedTicks; /* The tick hook gets called at regular intervals, even if the scheduler is locked. */ #if ( configUSE_TICK_HOOK == 1 ) &#123; vApplicationTickHook(); &#125; #endif &#125; return xSwitchRequired;&#125; 这个函数做了以下几件事情： 检查延时列表中的任务等待时间是否已到，如果到了，就恢复任务到就绪列表 当时间片开启时，且换相同优先级任务，当然，不是在这个函数里面切换，这个函数只是通过返回值告诉调用者是否要切换 判断延时列表是否已经超时时，要判断tick的溢出情况，溢出了要做进一步除了，以后深入分析该过程。 除了systick定时器会切换线程外，其他操作比如任务阻塞、延时等也会造成任务切换。 未完待续…… 如有错误，欢迎指出！如需转载，请注明出处~email:&#99;&#x72;&#101;&#x61;&#116;&#105;&#118;&#101;&#x2e;&#x77;&#x6f;&#114;&#x6b;&#46;&#103;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;欢迎交流学习！","categories":[{"name":"rtos","slug":"rtos","permalink":"https://creworkg.github.io/categories/rtos/"},{"name":"sheduler context switch","slug":"rtos/sheduler-context-switch","permalink":"https://creworkg.github.io/categories/rtos/sheduler-context-switch/"}],"tags":[{"name":"rtos","slug":"rtos","permalink":"https://creworkg.github.io/tags/rtos/"}]},{"title":"HEXO Usage","slug":"HEXO-Usage","date":"2022-09-13T04:55:02.000Z","updated":"2022-09-14T09:47:34.091Z","comments":true,"path":"2022/09/13/HEXO-Usage/","link":"","permalink":"https://creworkg.github.io/2022/09/13/HEXO-Usage/","excerpt":"","text":"Hexo Usage Hexo-theme-pure config Theme Next Doc","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://creworkg.github.io/tags/Hexo/"}]},{"title":"freeRTOS-任务创建过程分析","slug":"freeRTOS-任务创建过程分析","date":"2022-09-12T13:51:16.000Z","updated":"2022-09-17T06:38:03.032Z","comments":true,"path":"2022/09/12/freeRTOS-任务创建过程分析/","link":"","permalink":"https://creworkg.github.io/2022/09/12/freeRTOS-%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/","excerpt":"pre { overflow-y: auto; max-height: 600px; } xTaskCreate","text":"pre { overflow-y: auto; max-height: 600px; } xTaskCreate 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687BaseType_t xTaskCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */&#123;TCB_t *pxNewTCB;BaseType_t xReturn; /* If the stack grows down then allocate the stack then the TCB so the stack does not grow into the TCB. Likewise if the stack grows up then allocate the TCB then the stack. */ #if( portSTACK_GROWTH &gt; 0 ) &#123; /* Allocate space for the TCB. Where the memory comes from depends on the implementation of the port malloc function and whether or not static allocation is being used. */ pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); if( pxNewTCB != NULL ) &#123; /* Allocate space for the stack used by the task being created. The base of the stack memory stored in the TCB so the task can be deleted later if required. */ pxNewTCB-&gt;pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */ if( pxNewTCB-&gt;pxStack == NULL ) &#123; /* Could not allocate the stack. Delete the allocated TCB. */ vPortFree( pxNewTCB ); pxNewTCB = NULL; &#125; &#125; &#125; #else /* portSTACK_GROWTH */ &#123; StackType_t *pxStack; /* Allocate space for the stack used by the task being created. */ pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */ if( pxStack != NULL ) &#123; /* Allocate space for the TCB. */ pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */ if( pxNewTCB != NULL ) &#123; /* Store the stack location in the TCB. */ pxNewTCB-&gt;pxStack = pxStack; &#125; else &#123; /* The stack cannot be used as the TCB was not created. Free it again. */ vPortFree( pxStack ); &#125; &#125; else &#123; pxNewTCB = NULL; &#125; &#125; #endif /* portSTACK_GROWTH */ if( pxNewTCB != NULL ) &#123; #if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) &#123; /* Tasks can be created statically or dynamically, so note this task was created dynamically in case it is later deleted. */ pxNewTCB-&gt;ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB; &#125; #endif /* configSUPPORT_STATIC_ALLOCATION */ prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL ); prvAddNewTaskToReadyList( pxNewTCB ); xReturn = pdPASS; &#125; else &#123; xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY; &#125; return xReturn;&#125; 分析这个函数主要做了以下事情： 根据栈的生长方向，来确定TCB和stack的申请先后顺序，这样做的目的是什么呢？ 调用 prvInitialiseNewTask函数初始化TCB和stack 调用 prvAddNewTaskToReadyList函数，将任务挂载到就緒列表上 接下来看看函數 prvInitialiseNewTask做了什么。 prvInitialiseNewTask123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194static void prvInitialiseNewTask( TaskFunction_t pxTaskCode, const char * const pcName, const uint32_t ulStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, TCB_t *pxNewTCB, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */&#123;StackType_t *pxTopOfStack;UBaseType_t x; #if( portUSING_MPU_WRAPPERS == 1 ) /* Should the task be created in privileged mode? */ BaseType_t xRunPrivileged; if( ( uxPriority &amp; portPRIVILEGE_BIT ) != 0U ) &#123; xRunPrivileged = pdTRUE; &#125; else &#123; xRunPrivileged = pdFALSE; &#125; uxPriority &amp;= ~portPRIVILEGE_BIT; #endif /* portUSING_MPU_WRAPPERS == 1 */ /* Avoid dependency on memset() if it is not required. */ #if( ( configCHECK_FOR_STACK_OVERFLOW &gt; 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) &#123; /* Fill the stack with a known value to assist debugging. */ ( void ) memset( pxNewTCB-&gt;pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) ); &#125; #endif /* ( ( configCHECK_FOR_STACK_OVERFLOW &gt; 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */ /* Calculate the top of stack address. This depends on whether the stack grows from high memory to low (as per the 80x86) or vice versa. portSTACK_GROWTH is used to make the result positive or negative as required by the port. */ #if( portSTACK_GROWTH &lt; 0 ) &#123; pxTopOfStack = pxNewTCB-&gt;pxStack + ( ulStackDepth - ( uint32_t ) 1 ); pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) &amp; ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception. Avoiding casts between pointers and integers is not practical. Size differences accounted for using portPOINTER_SIZE_TYPE type. */ /* Check the alignment of the calculated top of stack is correct. */ configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack &amp; ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) ); &#125; #else /* portSTACK_GROWTH */ &#123; pxTopOfStack = pxNewTCB-&gt;pxStack; /* Check the alignment of the stack buffer is correct. */ configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB-&gt;pxStack &amp; ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) ); /* The other extreme of the stack space is required if stack checking is performed. */ pxNewTCB-&gt;pxEndOfStack = pxNewTCB-&gt;pxStack + ( ulStackDepth - ( uint32_t ) 1 ); &#125; #endif /* portSTACK_GROWTH */ /* Store the task name in the TCB. */ for( x = ( UBaseType_t ) 0; x &lt; ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ ) &#123; pxNewTCB-&gt;pcTaskName[ x ] = pcName[ x ]; /* Don&#x27;t copy all configMAX_TASK_NAME_LEN if the string is shorter than configMAX_TASK_NAME_LEN characters just in case the memory after the string is not accessible (extremely unlikely). */ if( pcName[ x ] == 0x00 ) &#123; break; &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; /* Ensure the name string is terminated in the case that the string length was greater or equal to configMAX_TASK_NAME_LEN. */ pxNewTCB-&gt;pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = &#x27;\\0&#x27;; /* This is used as an array index so must ensure it&#x27;s not too large. First remove the privilege bit if one is present. */ if( uxPriority &gt;= ( UBaseType_t ) configMAX_PRIORITIES ) &#123; uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U; &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; pxNewTCB-&gt;uxPriority = uxPriority; #if ( configUSE_MUTEXES == 1 ) &#123; pxNewTCB-&gt;uxBasePriority = uxPriority; pxNewTCB-&gt;uxMutexesHeld = 0; &#125; #endif /* configUSE_MUTEXES */ vListInitialiseItem( &amp;( pxNewTCB-&gt;xStateListItem ) ); vListInitialiseItem( &amp;( pxNewTCB-&gt;xEventListItem ) ); /* Set the pxNewTCB as a link back from the ListItem_t. This is so we can get back to the containing TCB from a generic item in a list. */ listSET_LIST_ITEM_OWNER( &amp;( pxNewTCB-&gt;xStateListItem ), pxNewTCB ); /* Event lists are always in priority order. */ listSET_LIST_ITEM_VALUE( &amp;( pxNewTCB-&gt;xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */ listSET_LIST_ITEM_OWNER( &amp;( pxNewTCB-&gt;xEventListItem ), pxNewTCB ); #if ( portCRITICAL_NESTING_IN_TCB == 1 ) &#123; pxNewTCB-&gt;uxCriticalNesting = ( UBaseType_t ) 0U; &#125; #endif /* portCRITICAL_NESTING_IN_TCB */ #if ( configUSE_APPLICATION_TASK_TAG == 1 ) &#123; pxNewTCB-&gt;pxTaskTag = NULL; &#125; #endif /* configUSE_APPLICATION_TASK_TAG */ #if ( configGENERATE_RUN_TIME_STATS == 1 ) &#123; pxNewTCB-&gt;ulRunTimeCounter = 0UL; &#125; #endif /* configGENERATE_RUN_TIME_STATS */ #if ( portUSING_MPU_WRAPPERS == 1 ) &#123; vPortStoreTaskMPUSettings( &amp;( pxNewTCB-&gt;xMPUSettings ), xRegions, pxNewTCB-&gt;pxStack, ulStackDepth ); &#125; #else &#123; /* Avoid compiler warning about unreferenced parameter. */ ( void ) xRegions; &#125; #endif #if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 ) &#123; for( x = 0; x &lt; ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ ) &#123; pxNewTCB-&gt;pvThreadLocalStoragePointers[ x ] = NULL; &#125; &#125; #endif #if ( configUSE_TASK_NOTIFICATIONS == 1 ) &#123; pxNewTCB-&gt;ulNotifiedValue = 0; pxNewTCB-&gt;ucNotifyState = taskNOT_WAITING_NOTIFICATION; &#125; #endif #if ( configUSE_NEWLIB_REENTRANT == 1 ) &#123; /* Initialise this task&#x27;s Newlib reent structure. */ _REENT_INIT_PTR( ( &amp;( pxNewTCB-&gt;xNewLib_reent ) ) ); &#125; #endif #if( INCLUDE_xTaskAbortDelay == 1 ) &#123; pxNewTCB-&gt;ucDelayAborted = pdFALSE; &#125; #endif /* Initialize the TCB stack to look as if the task was already running, but had been interrupted by the scheduler. The return address is set to the start of the task function. Once the stack has been initialised the top of stack variable is updated. */ #if( portUSING_MPU_WRAPPERS == 1 ) &#123; pxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged ); &#125; #else /* portUSING_MPU_WRAPPERS */ &#123; pxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters ); &#125; #endif /* portUSING_MPU_WRAPPERS */ if( ( void * ) pxCreatedTask != NULL ) &#123; /* Pass the handle out in an anonymous way. The handle can be used to change the created task&#x27;s priority, delete the created task, etc.*/ *pxCreatedTask = ( TaskHandle_t ) pxNewTCB; &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125;&#125; 根据栈的生长方向来初始化栈顶指针 pxTopOfStack 1234567891011121314151617181920#if( portSTACK_GROWTH &lt; 0 )&#123; pxTopOfStack = pxNewTCB-&gt;pxStack + ( ulStackDepth - ( uint32_t ) 1 ); pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) &amp; ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception. Avoiding casts between pointers and integers is not practical. Size differences accounted for using portPOINTER_SIZE_TYPE type. */ /* Check the alignment of the calculated top of stack is correct. */ configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack &amp; ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );&#125;#else /* portSTACK_GROWTH */&#123; pxTopOfStack = pxNewTCB-&gt;pxStack; /* Check the alignment of the stack buffer is correct. */ configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB-&gt;pxStack &amp; ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) ); /* The other extreme of the stack space is required if stack checking is performed. */ pxNewTCB-&gt;pxEndOfStack = pxNewTCB-&gt;pxStack + ( ulStackDepth - ( uint32_t ) 1 );&#125;#endif /* portSTACK_GROWTH */ 向下生长时，将 pxTopOfStack指向最高地址，并且要字节对齐，目的是提高数据访问效率；向上生长时，将 pxTopOfStack指向最低地址，同样要字节对齐2. 将任务名存入TCB，如果过长的话，做截断处理3. 处理优先级，便于插入链表时，做排序，以及优先级反转的时候保存原来的优先级4. 初始化状态链表项 xStateListItem和事件链表项 xStateListItem5. 初始化链表的所有者，将 xStateListItem和 xEventListItem指向TCB首地址6. 将优先级写入 xEventListItem中7. 调用 pxPortInitialiseStack初始化stack 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#define portINITIAL_XPSR ( 0x01000000 )#define portSTART_ADDRESS_MASK ( ( StackType_t ) 0xfffffffeUL )static void prvTaskExitError( void )&#123; /* A function that implements a task must not exit or attempt to return to its caller as there is nothing to return to. If a task wants to exit it should instead call vTaskDelete( NULL ). Artificially force an assert() to be triggered if configASSERT() is defined, then stop here so application writers can catch the error. */ configASSERT( uxCriticalNesting == ~0UL ); portDISABLE_INTERRUPTS(); for( ;; );&#125;/*CM3版本*/StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )&#123; /* Simulate the stack frame as it would be created by a context switch interrupt. */ pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */ *pxTopOfStack = portINITIAL_XPSR; /* xPSR */ pxTopOfStack--; *pxTopOfStack = ( ( StackType_t ) pxCode ) &amp; portSTART_ADDRESS_MASK; /* PC */ pxTopOfStack--; *pxTopOfStack = ( StackType_t ) prvTaskExitError; /* LR */ pxTopOfStack -= 5; /* R12, R3, R2 and R1. */ *pxTopOfStack = ( StackType_t ) pvParameters; /* R0 */ pxTopOfStack -= 8; /* R11, R10, R9, R8, R7, R6, R5 and R4. */ return pxTopOfStack;&#125;/*CM4版本*/#define portINITIAL_EXEC_RETURN ( 0xfffffffd )StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )&#123; /* Simulate the stack frame as it would be created by a context switch interrupt. */ /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts, and to ensure alignment. */ pxTopOfStack--; *pxTopOfStack = portINITIAL_XPSR; /* xPSR */ pxTopOfStack--; *pxTopOfStack = ( ( StackType_t ) pxCode ) &amp; portSTART_ADDRESS_MASK; /* PC */ pxTopOfStack--; *pxTopOfStack = ( StackType_t ) prvTaskExitError; /* LR */ /* Save code space by skipping register initialisation. */ pxTopOfStack -= 5; /* R12, R3, R2 and R1. */ *pxTopOfStack = ( StackType_t ) pvParameters; /* R0 */ /* A save method is being used that requires each task to maintain its own exec return value. */ pxTopOfStack--; *pxTopOfStack = portINITIAL_EXEC_RETURN; pxTopOfStack -= 8; /* R11, R10, R9, R8, R7, R6, R5 and R4. */ return pxTopOfStack;&#125; 为什么 portINITIAL_XPSR的值为 0x01000000呢？将xPSR寄存器的第24位置一，使cpu执行用户任务时，使用 Thumb指令，而非 ARM指令，执行 ARM就会出错，因为CM3&#x2F;4不支持 ARM指令 将 pxCode(用户代码首地址)和 0xfffffffeUL进行按位与，也就是将LSB置为0，因为PC指针的指令地址必须对齐到半字或字地址，这个操作会不会产生问题？GOD! 把代码地址都改变了？实际上不会，想想为什么吧。 prvTaskExitError函数先关闭中断，然后进入无限循环 将 R0指向 pvParameters为什么要以这样的方式初始化栈，因为做线程切换的时候，寄存器的保持顺序是：xPSR, PC, LR, R12, R3-R0(caller-saved register), 然后是 R11, R10, R9, R8, R7, R6, R5 and R4,这几个寄存器是 callee-saved register。所以当该任务获取到cpu使用权时，以上参数将被填入cpu内部寄存器中。所以一些 caller-saved register保持空缺的原因是，还没运行过，根本就没有参数可以保存嘛，当然，不能忽视的是，pvParameters要传入到R0，因为参数的传递过程就是由 R0-R3实现的，当函数A调用函数B时，需要传递参数，则要将参数先复制到这几个寄存器中，然后再跳转到B执行。如果传递的参数大于4个怎么办，就要通过栈帧传递了，把前四个参数复制到 R0-R3中，把剩余参数放在stack中，这就是为什么参数的传递尽量使用指针和引用的原因了，当然也不绝对，只要减少复制过程就能提高运行速度，所以，结论是：大数据的传递使用指针，小数据传递，使用值传递。 portINITIAL_EXEC_RETURN用于在退出 SVC和 PendSV时，使用线程栈。发现，在CM3版本中，并没有这一步，具体原因待查。 再看看 prvAddNewTaskToReadyList函数的执行过程： prvAddNewTaskToReadyList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )&#123; /* Ensure interrupts don&#x27;t access the task lists while the lists are being updated. */ taskENTER_CRITICAL(); &#123; uxCurrentNumberOfTasks++; if( pxCurrentTCB == NULL ) &#123; /* There are no other tasks, or all the other tasks are in the suspended state - make this the current task. */ pxCurrentTCB = pxNewTCB; if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 ) &#123; /* This is the first task to be created so do the preliminary initialisation required. We will not recover if this call fails, but we will report the failure. */ prvInitialiseTaskLists(); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; else &#123; /* If the scheduler is not already running, make this task the current task if it is the highest priority task to be created so far. */ if( xSchedulerRunning == pdFALSE ) &#123; if( pxCurrentTCB-&gt;uxPriority &lt;= pxNewTCB-&gt;uxPriority ) &#123; pxCurrentTCB = pxNewTCB; &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; uxTaskNumber++; #if ( configUSE_TRACE_FACILITY == 1 ) &#123; /* Add a counter into the TCB for tracing only. */ pxNewTCB-&gt;uxTCBNumber = uxTaskNumber; &#125; #endif /* configUSE_TRACE_FACILITY */ traceTASK_CREATE( pxNewTCB ); prvAddTaskToReadyList( pxNewTCB ); portSETUP_TCB( pxNewTCB ); &#125; taskEXIT_CRITICAL(); if( xSchedulerRunning != pdFALSE ) &#123; /* If the created task is of a higher priority than the current task then it should run now. */ if( pxCurrentTCB-&gt;uxPriority &lt; pxNewTCB-&gt;uxPriority ) &#123; taskYIELD_IF_USING_PREEMPTION(); &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125; &#125; else &#123; mtCOVERAGE_TEST_MARKER(); &#125;&#125; 进来第一件事情就是关掉中断，独享的moment不能让别人打扰，不然就会出错 将当前存在的任务数加一 如果 pxCurrentTCB为 NULL，表明这是系统启动后的第一个任务，要先初始化链表，稍后讲。 如果 pxCurrentTCB不为 NULL，并且調度器未开启，则将当前任务指针指向该任务。 将任务插入到就绪链表的末端。 怎么选出优先级最高的任务呢？使用硬件实现，叫做前导零算法，使用 __clz指令。 123456789/* * Place the task represented by pxTCB into the appropriate ready list for * the task. It is inserted at the end of the list. */#define prvAddTaskToReadyList( pxTCB ) \\ traceMOVED_TASK_TO_READY_STATE( pxTCB ); \\ taskRECORD_READY_PRIORITY( ( pxTCB )-&gt;uxPriority ); \\ vListInsertEnd( &amp;( pxReadyTasksLists[ ( pxTCB )-&gt;uxPriority ] ), &amp;( ( pxTCB )-&gt;xStateListItem ) ); \\ tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB ) taskRECORD_READY_PRIORITY将所有的线程中，最高的优先级赋给 uxTopReadyPriority，有两种不同的实现，以下为其中一种： 1234567#define taskRECORD_READY_PRIORITY( uxPriority ) \\&#123; \\ if( ( uxPriority ) &gt; uxTopReadyPriority ) \\ &#123; \\ uxTopReadyPriority = ( uxPriority ); \\ &#125; \\&#125; /* taskRECORD_READY_PRIORITY */ 然后将 TCB插入到优先级对应的就绪列表的尾部，就绪列表按照优先级划分为多个，具有相同的优先级任务挂在同一个就绪列表中。 开启中断 是否要进行线程切换，切换就使用：taskYIELD_IF_USING_PREEMPTION，该宏最终会调用到 portYIELD，可以看出，更高优先级的任务一创建就会马上夺取cpu的使用权 12345678910#define portYIELD() \\&#123; \\ /* Set a PendSV to request a context switch. */ \\ portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; \\ \\ /* Barriers are normally not required but do ensure the code is completely \\ within the specified behaviour for the architecture. */ \\ __dsb( portSY_FULL_READ_WRITE ); \\ __isb( portSY_FULL_READ_WRITE ); \\&#125; 请求 PendSV中断，线程就是在这个中断中切换的。 如有错误，欢迎指出！如需转载，请注明出处~email:&#99;&#x72;&#101;&#x61;&#x74;&#105;&#118;&#x65;&#46;&#119;&#x6f;&#114;&#107;&#46;&#103;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#109;欢迎交流学习！","categories":[{"name":"rtos","slug":"rtos","permalink":"https://creworkg.github.io/categories/rtos/"},{"name":"task create","slug":"rtos/task-create","permalink":"https://creworkg.github.io/categories/rtos/task-create/"}],"tags":[{"name":"rtos","slug":"rtos","permalink":"https://creworkg.github.io/tags/rtos/"}]},{"title":"ZEN","slug":"ZEN","date":"2022-09-10T13:51:16.000Z","updated":"2022-09-15T14:26:15.402Z","comments":true,"path":"2022/09/10/ZEN/","link":"","permalink":"https://creworkg.github.io/2022/09/10/ZEN/","excerpt":"当你做某件事的时候，一旦想要求快，就表示你在也不关心它，只想去做别的事。《禅与摩托车维修艺术》","text":"当你做某件事的时候，一旦想要求快，就表示你在也不关心它，只想去做别的事。《禅与摩托车维修艺术》 禅，是踏实的态度，一步一个脚印，确定方向和方法，坚持原则和目标，时时努力，事事检讨，确实把握时间、空间的因缘聚会。 学习禅法的人，一定是非常踏实、认真的生活，生活中有方法，有方向，有原则，有目标，而且是不断地努力。 以过程为目标，以失败为经验，已成功为起点，以现在为全部。 不眷恋过去，不夢想未來，是將全部的生命，活活潑潑投注於現在。 不眷戀過去，不夢想未來，隨時隨地努力於現在。 超越的態度是，超越個人的得失，超越暫時的成敗，超越有形的強弱，超越有無的價值，超越自我的執著。 逐步的成功，一步有一步的成功，一時有一時的成功。 「無所住」就是不執著任何事，但也不是住在定中不動，而是以智慧心和慈悲心，在平常生活中，照樣的生活、待人接物。 小成功是個人的，一時的、局部的，大成功是團體的，社會的、全民全世界的，能歷久彌新、普遍廣大，具有正面影響力。 但求奉獻自己，普度眾生，離苦得樂，才能做到究竟圓滿的大成功。 佛法中悲智雙運、福慧滿足，就是人格的大完成，做人完全成功就能成佛，人成即佛成。 方法是，用自己的才能，配合擁有的資源，並要運用先天的福報和智慧。 方法要不斷學習、練習，不斷試驗、體會，再修正偏差，再選擇。 要多學習、多練習，多吸取前人的經驗，多聽專家的忠告，多了解自己，多觀察環境。 時時學習著，提得起·放得下，收放自如，進退自由，當進則進，當退则退。 以人格的成長，道德的成熟，求得身心的平安，無愧於天、無愧於地，無愧於自己的心，就算是成功。 —圣严法师","categories":[{"name":"zen","slug":"zen","permalink":"https://creworkg.github.io/categories/zen/"}],"tags":[{"name":"zen","slug":"zen","permalink":"https://creworkg.github.io/tags/zen/"}]},{"title":"WISDOM","slug":"wisdom","date":"2022-09-10T13:51:16.000Z","updated":"2022-09-17T00:44:49.238Z","comments":true,"path":"2022/09/10/wisdom/","link":"","permalink":"https://creworkg.github.io/2022/09/10/wisdom/","excerpt":"你的时间有限，所以不要为别人而活。不要被教条所限，不要活在别人的观念里。不要让别人的意见左右自己内心的声音，最重要的是，勇敢地去追随自己的心灵和直觉，只有自己的心灵和直觉才知道你自己的真实想法，其它一切都是次要。你的时间有限，所以不要为别人而活。 “记住你即将死去”是我一生中遇到的最重要箴言。它帮我指明了生命中重要的选择，因为几乎所有的事情，包括所有的荣誉、所有的骄傲、所有对难堪和失败的恐惧，这些在死亡面前都会消失，我看到的是留下的真止重要的乐西。","text":"你的时间有限，所以不要为别人而活。不要被教条所限，不要活在别人的观念里。不要让别人的意见左右自己内心的声音，最重要的是，勇敢地去追随自己的心灵和直觉，只有自己的心灵和直觉才知道你自己的真实想法，其它一切都是次要。你的时间有限，所以不要为别人而活。 “记住你即将死去”是我一生中遇到的最重要箴言。它帮我指明了生命中重要的选择，因为几乎所有的事情，包括所有的荣誉、所有的骄傲、所有对难堪和失败的恐惧，这些在死亡面前都会消失，我看到的是留下的真止重要的乐西。 在你生命的最初30年中，你养成习惯；在你生命的最后的30年中，你的习惯决定了你。 专注和简单一直是我的秘块之一。简单可能比复杂更难做到：你必须努力理清思路，从而使其变得简单，最终这是值得的，因为一旦你做到了，便可以创造奇迹。 拥有初学者的心态是件了不起的事情，所谓初学者的心态是指，不要无端猜测、不要期望、不要武断也不要偏见，初学者的心态正如一个新生儿面对这个世界一样，永远充满好奇、求知欲、赞叹。 如果你很忙，除了你真的很重要以外，更可能的原因是：你很弱，你没有什么更好的事情去做，你生活太差不得不努力来弥补，或者你装作你很忙，让自己显得很重要。 自由从何而来？从自信来，而自信则是从自律来！先学会克制自己，用严格的日程表控制生活，才能在这种自律中不断磨练出自信：自信是对事情的控制能力，如果你连最基本的时间都做控制不了，还谈什么自信？ form Jobs 泡夜店、纹身、买醉，这些事情看起来很酷，其实一点难度都没有，只有你想办到随时都可以。 真正酷的，应该是那些不容易办到的，比如：读书、赚钱、健身、早睡早起、孝顺父母，用炙热的心爱人爱己，用你毕生的精力去战胜一个个专业领域。 低级的欲望放纵即可获得，高级的欲望只有克制才能达成。 form 人民日报 人这辈子千万不要马虎两件事，一是找对爱人，二是找对事业，因为太阳升起时要投身事业，太阳落山是要与爱人相拥的。我们终其一生，都在寻找两个东西，一个是价值感，一个是归属感。价值感来自于被肯定，归属感来自于被爱…… 是的，不论你多么富有，多么有权势，当生命结束之时，所有的一切都只能留在世界上，唯有灵魂跟着你走下一段旅程。人生不是一场物质的盛宴，而是一次灵魂的修炼，使它在谢幕之时比开幕之初更为高尚。 form 稻盛和夫","categories":[{"name":"zen","slug":"zen","permalink":"https://creworkg.github.io/categories/zen/"}],"tags":[{"name":"zen","slug":"zen","permalink":"https://creworkg.github.io/tags/zen/"}]}],"categories":[{"name":"zen","slug":"zen","permalink":"https://creworkg.github.io/categories/zen/"},{"name":"thoughts","slug":"zen/thoughts","permalink":"https://creworkg.github.io/categories/zen/thoughts/"},{"name":"rtos","slug":"rtos","permalink":"https://creworkg.github.io/categories/rtos/"},{"name":"sheduler context switch","slug":"rtos/sheduler-context-switch","permalink":"https://creworkg.github.io/categories/rtos/sheduler-context-switch/"},{"name":"task create","slug":"rtos/task-create","permalink":"https://creworkg.github.io/categories/rtos/task-create/"}],"tags":[{"name":"zen","slug":"zen","permalink":"https://creworkg.github.io/tags/zen/"},{"name":"rtos","slug":"rtos","permalink":"https://creworkg.github.io/tags/rtos/"},{"name":"Hexo","slug":"Hexo","permalink":"https://creworkg.github.io/tags/Hexo/"}]}